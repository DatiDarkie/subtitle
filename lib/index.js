(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('subtitles-ssa'), require('subtitles-parser')) :
  typeof define === 'function' && define.amd ? define(['exports', 'subtitles-ssa', 'subtitles-parser'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SubtitleController = {}, global.subtitlesSsa, global.subtitlesParser));
})(this, (function (exports, subtitlesSsa, subtitlesParser) { 'use strict';

  var TIME_PATTERN = /(\d+):(\d{2}):(\d{2})[\.,](\d{3})/;

  var Time = function (value) {
    this.time = isFinite(value) ? Number(value) : Time.timeToNumber(value);
    this.comma = typeof value === "string" ? (value.includes(".") ? "." : ",") : ".";
  };

  Time.prototype.add = function (ms) {
    if (!isFinite(ms)) { return false; }
    ms = ms * 1;
    this.time = this.valueOf() + ms;
    return this;
  };

  Time.prototype.minus = function (ms) {
    if (!isFinite(ms)) { return false; }
    ms = ms * 1;
      
    this.time = this.valueOf() - ms;
    if (this.time < 0) {
      this.time = 0;
    }

    return this;
  };

  Time.prototype.valueOf = function () {
    return this.time;
  };

  Time.prototype.toString = function (comma) {
      if ( comma === void 0 ) comma = this.comma;

    return Time.timeToString(this.time, comma);
  };

  Time.isValidTime = function (val) {
    switch (typeof val) {
      case "string":
        return !!TIME_PATTERN.exec(val);
      case "number":
        return isFinite(val);
      default:
        return false;
    }
  };

  Time.timeToNumber = function (val) {
    var parts = TIME_PATTERN.exec(val);
    
    if (parts === null) { return 0; }
    
    for (var i = 1; i < 5; i++) {
      parts[i] = parseInt(parts[i], 10);
      if (isNaN(parts[i])) { parts[i] = 0; }
    }
      
    return Number(parts[1] * 3600000 + parts[2] * 60000 + parts[3] * 1000 + parts[4]);
  };

  Time.timeToString = function (val, comma) {
      if ( comma === void 0 ) comma = ",";

    var measures = [ 3600000, 60000, 1000 ]; 
    var time = [];

    for (var i in measures) {
      var res = (val / measures[i] >> 0).toString();
        
      if (res.length < 2) { res = '0' + res; }
      val %= measures[i];
      time.push(res);
    }

    var ms = val.toString();
    if (ms.length < 3) {
      for (var i$1 = 0; i$1 <= 3 - ms.length; i$1++) { ms = '0' + ms; }
    }

    return time.join(':') + comma + ms; 
  };

  var Dialogue = function (data) {
    if ( data === void 0 ) data = {};

    var text = data.text;

    if (typeof data === "string") { text = data; }

    var start = data.start || data.startTime;
    var end = data.end || data.endTime;
    var secondaryText = data.secondaryText;

    this.start = new Time(start);
    this.end = new Time(end);
    this.text = text || "";
    this.secondaryText = secondaryText || "";
  };

  Dialogue.createEmpty = function () {
    return new Dialogue();
  };

  Dialogue.prototype.clone = function () {
    return new Dialogue(this);
  };

  Dialogue.prototype.toJSON = function () {
    return {
      text: this.text || "",
      secondaryText: this.secondaryText || "",
      start: this.start.valueOf(),
      end: this.end.valueOf()
    }
  };

  Dialogue.prototype.toString = function () {
    return "[Dialogue]";
  };

  Dialogue.prototype.valueOf = function () {
    return this.toJSON();
  };

  function parse$2 (str) {
    var dialogues = subtitlesSsa.parse(str);
    
    for (var i = 0; i < dialogues.length; i++) {
      var dialogue = dialogues[i];
      dialogues[i] = new Dialogue(dialogue);
    }

    return dialogues;
  }

  function convert$2 (dialogues) {
    if (!Array.isArray(dialogues)) { return null; }
    
    for (var i = 0; i < dialogues.length; i++) {
      var dialogue = dialogues[i];
      dialogues[i] = new Dialogue(dialogue).toJSON();
    }

    return subtitlesSsa.convert(dialogues);
  }

  function parse$1 (str) {
    var lines = str.split("\n");
    var dialogues = [];

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      
      if (!line.startsWith("Dialogue: ")) {
        continue;
      }

      var ref = line.match(/(\d),(\d{1,}:?\d{1,2}:\d{1,2}[,.]\d{1,3}),(\d{1,}:?\d{1,2}:\d{1,2}[,.]\d{1,3}),(\w+)?,(\w+)?,(\d+),(\d+),(\d+),(\w+)?,(.+)/);
      var start = ref[2];
      var end = ref[3];
      var text = ref[10];
      console.log(start, end);
      dialogues.push(
        new Dialogue({ start: start, end: end, text: text })
      );
    }

    return dialogues;
  }

  function convert$1 (dialogues) {
    if (!Array.isArray(dialogues)) { return null; }
    
    var headerStr = "[Script Info]\n; Script generated by Aegisub 3.2.2\n; http://www.aegisub.org/\nTitle: Default Aegisub file\nScriptType: v4.00+\nWrapStyle: 0\nScaledBorderAndShadow: yes\nYCbCr Matrix: None\n[Aegisub Project Garbage]\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n";

    return headerStr + dialogues.map(
      function (dialogue) { return ("Dialogue: 0," + (dialogue.end.toString(".")) + "," + (dialogue.end.toString(".")) + ",Default,,0,0,0,," + (dialogue.text)); }
    );
  }

  function parse (str) {
    var dialogues = subtitlesParser.fromSrt(str, true);
    
    for (var i = 0; i < dialogues.length; i++) {
      var dialogue = dialogues[i];
      dialogues[i] = new Dialogue(dialogue);
    }

    return dialogues;
  }

  function convert (dialogues) {
    if (!Array.isArray(dialogues)) { return null; }
    
    for (var i = 0; i < dialogues.length; i++) {
      var dialogue = new Dialogue(dialogues[i]);
      dialogues[i] = { id: i + 1, startTime: dialogue.start.valueOf(), endTime: dialogue.end.valueOf(), text: dialogue.text || "" };
    }

    return subtitlesParser.toSrt(dialogues).replace(/\r/g, "");
  }

  exports.Dialogue = Dialogue;
  exports.Time = Time;
  exports.fromAss = parse$1;
  exports.fromSrt = parse;
  exports.fromSsa = parse$2;
  exports.toAss = convert$1;
  exports.toSrt = convert;
  exports.toSsa = convert$2;

}));
